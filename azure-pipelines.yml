trigger:
  branches:
    include:
      - main

pool:
  vmImage: 'windows-latest'

variables:
  azureSubscription: 'AzureConnection-UAMI'
  functionAppName: 'iothubandroid'
  resourceGroup: 'iothost'
  buildConfig: 'Release'

steps:
- task: UseDotNet@2
  displayName: 'Install .NET 8.0 SDK'
  inputs:
    packageType: 'sdk'
    version: '8.0.x'

- task: DotNetCoreCLI@2
  displayName: 'Restore packages'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  displayName: 'Build project'
  inputs:
    command: 'build'
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfig) --no-restore'

- task: DotNetCoreCLI@2
  displayName: 'Publish project'
  inputs:
    command: 'publish'
    projects: '*.csproj'
    publishWebProjects: false
    arguments: '--configuration $(buildConfig) --output publish_output'
    modifyOutputPath: false
    zipAfterPublish: false

- task: ArchiveFiles@2
  displayName: 'Archive files'
  inputs:
    rootFolderOrFile: '$(System.DefaultWorkingDirectory)/publish_output'
    includeRootFolder: false
    archiveFile: '$(System.DefaultWorkingDirectory)/build$(Build.BuildId).zip'
    replaceExistingArchive: true

# Verificar contenido antes del deploy
- task: PowerShell@2
  displayName: 'Verify package contents'
  inputs:
    targetType: 'inline'
    script: |
      $zipPath = "$(System.DefaultWorkingDirectory)/build$(Build.BuildId).zip"
      Add-Type -AssemblyName System.IO.Compression.FileSystem
      $zip = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
      
      Write-Host "=== Contenido del ZIP ==="
      $zip.Entries | ForEach-Object {
          Write-Host "  - $($_.FullName)"
      }
      
      # Verificar archivos críticos
      $hostJson = $zip.Entries | Where-Object { $_.FullName -eq "host.json" }
      if ($hostJson) {
          Write-Host "✓ host.json encontrado"
      } else {
          Write-Host "❌ host.json NO encontrado - CRÍTICO"
      }
      
      $zip.Dispose()

- task: PublishBuildArtifacts@1
  displayName: 'Publish build artifacts'
  inputs:
    PathtoPublish: '$(System.DefaultWorkingDirectory)/build$(Build.BuildId).zip'
    artifactName: 'drop'

- task: AzureFunctionApp@2
  displayName: 'Deploy Azure Function App'
  inputs:
    connectedServiceNameARM: '$(azureSubscription)'
    appType: 'functionApp'
    appName: '$(functionAppName)'
    package: '$(System.DefaultWorkingDirectory)/build$(Build.BuildId).zip'
    deploymentMethod: 'zipDeploy'

# Post-deployment: Reiniciar y sincronizar
- task: AzureCLI@2
  displayName: 'Post-deployment: Restart and sync'
  inputs:
    azureSubscription: '$(azureSubscription)'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      Write-Host "=== Post-deployment verification ==="
      
      # Reiniciar Function App
      Write-Host "Reiniciando Function App..."
      az functionapp restart --name $(functionAppName) --resource-group $(resourceGroup)
      
      # Esperar estabilización
      Write-Host "Esperando estabilización..."
      Start-Sleep -Seconds 45
      
      # Sincronizar triggers
      Write-Host "Sincronizando triggers..."
      az functionapp deployment source sync --name $(functionAppName) --resource-group $(resourceGroup)
      
      # Verificar funciones
      Write-Host "Verificando funciones desplegadas..."
      $functions = az functionapp function list --name $(functionAppName) --resource-group $(resourceGroup) --output table
      Write-Host $functions
      
      # Verificar estado del runtime
      $hostStatus = az functionapp show --name $(functionAppName) --resource-group $(resourceGroup) --query "hostingEnvironmentProfile" -o tsv
      Write-Host "Estado del hosting: $hostStatus"
