trigger:
  branches:
    include:
      - main

pool:
  vmImage: 'windows-latest'

variables:
  azureSubscription: 'AzureConnection-UAMI'
  functionAppName: 'iothubandroid'
  resourceGroup: 'iothost'
  buildConfig: 'Release'

steps:
- task: UseDotNet@2
  displayName: 'Install .NET 8.0 SDK'
  inputs:
    packageType: 'sdk'
    version: '8.0.x'

- task: DotNetCoreCLI@2
  displayName: 'Restore packages'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  displayName: 'Build project'
  inputs:
    command: 'build'
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfig) --no-restore'

# Publish optimizado para reducir tamaño
- task: DotNetCoreCLI@2
  displayName: 'Publish optimized'
  inputs:
    command: 'publish'
    publishWebProjects: false
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfig) --output $(Build.ArtifactStagingDirectory)/function-output --no-build --self-contained false --verbosity minimal'
    zipAfterPublish: false

# Limpiar archivos innecesarios para reducir tamaño
- task: PowerShell@2
  displayName: 'Optimize deployment package'
  inputs:
    targetType: 'inline'
    script: |
      $outputPath = "$(Build.ArtifactStagingDirectory)/function-output"
      
      Write-Host "=== Optimizando paquete de deployment ==="
      
      # Eliminar archivos innecesarios que aumentan el tamaño
      $filesToRemove = @(
          "*.pdb",           # Símbolos de debug
          "*.xml",           # Documentación XML
          "*.dev.json",      # Archivos de desarrollo
          "appsettings.Development.json"
      )
      
      foreach ($pattern in $filesToRemove) {
          $files = Get-ChildItem -Path $outputPath -Filter $pattern -Recurse
          foreach ($file in $files) {
              Write-Host "Eliminando: $($file.Name)"
              Remove-Item $file.FullName -Force
          }
      }
      
      # Verificar tamaño final
      $totalSize = (Get-ChildItem $outputPath -Recurse | Measure-Object -Property Length -Sum).Sum
      $totalSizeMB = [Math]::Round($totalSize / 1MB, 2)
      Write-Host "Tamaño optimizado: $totalSizeMB MB"

# Limpiar Azure antes del deploy
- task: AzureCLI@2
  displayName: 'Prepare Azure for deployment'
  inputs:
    azureSubscription: '$(azureSubscription)'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      # Configurar para deployment limpio
      az functionapp config appsettings set `
          --name $(functionAppName) `
          --resource-group $(resourceGroup) `
          --settings WEBSITE_RUN_FROM_PACKAGE=0 `
                    SCM_DO_BUILD_DURING_DEPLOYMENT=false

# Deploy usando método alternativo más confiable
- task: AzureCLI@2
  displayName: 'Deploy via Azure CLI (more reliable)'
  inputs:
    azureSubscription: '$(azureSubscription)'
    scriptType: 'ps'
    scriptLocation: 'inlineScript'
    inlineScript: |
      try {
          $outputPath = "$(Build.ArtifactStagingDirectory)/function-output"
          
          Write-Host "=== Iniciando deployment directo ==="
          
          # Deploy directo desde directorio (sin ZIP)
          Write-Host "Desplegando directamente desde directorio..."
          
          # Comprimir solo para el deploy
          $tempZip = "$(Agent.TempDirectory)/temp-deploy.zip"
          Compress-Archive -Path "$outputPath/*" -DestinationPath $tempZip -Force
          
          $zipSize = [Math]::Round((Get-Item $tempZip).Length / 1MB, 2)
          Write-Host "Tamaño del ZIP temporal: $zipSize MB"
          
          if ($zipSize -gt 250) {
              throw "ZIP demasiado grande: $zipSize MB. Máximo recomendado: 250MB"
          }
          
          # Deploy usando Azure CLI con timeout extendido
          az functionapp deployment source config-zip `
              --resource-group $(resourceGroup) `
              --name $(functionAppName) `
              --src $tempZip `
              --timeout 1200
          
          if ($LASTEXITCODE -ne 0) {
              throw "Deploy falló con código: $LASTEXITCODE"
          }
          
          Write-Host "✓ Deploy completado exitosamente"
          
          # Verificar funciones
          Start-Sleep -Seconds 10
          az functionapp function list --name $(functionAppName) --resource-group $(resourceGroup) --output table
          
      } catch {
          Write-Host "##vso[task.logissue type=error]Error: $($_.Exception.Message)"
          throw
      }
