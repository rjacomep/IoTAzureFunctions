trigger:
  branches:
    include:
      - main

pool:
  vmImage: 'windows-latest'

variables:
  azureSubscription: 'AzureConnection-UAMI'
  functionAppName: 'iothubandroid'
  resourceGroup: 'iothost'
  buildConfig: 'Release'

steps:
- task: UseDotNet@2
  displayName: 'Install .NET 8.0 SDK'
  inputs:
    packageType: 'sdk'
    version: '8.0.x'

- task: DotNetCoreCLI@2
  displayName: 'Restore packages'
  inputs:
    command: 'restore'
    projects: '**/*.csproj'

- task: DotNetCoreCLI@2
  displayName: 'Build project'
  inputs:
    command: 'build'
    projects: '**/*.csproj'
    arguments: '--configuration $(buildConfig) --no-restore'

# Método alternativo: usar dotnet publish con configuración específica para Functions
- task: PowerShell@2
  displayName: 'Create Function App package'
  inputs:
    errorActionPreference: 'stop'
    failOnStderr: false
    targetType: 'inline'
    script: |
      try {
          Write-Host "=== Creating Azure Function package ==="
          
          # Encontrar el proyecto
          $projectPath = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Filter "*.csproj" -Recurse | Select-Object -First 1
          if (-not $projectPath) {
              throw "No se encontró archivo .csproj"
          }
          
          $projectDir = $projectPath.DirectoryName
          Write-Host "Directorio del proyecto: $projectDir"
          
          # Crear directorio de salida
          $outputPath = "$(Build.ArtifactStagingDirectory)/function-output"
          New-Item -ItemType Directory -Path $outputPath -Force
          
          # Publicar usando dotnet con configuraciones específicas para Azure Functions
          Write-Host "Ejecutando dotnet publish..."
          Set-Location $projectDir
          
          dotnet publish `
              --configuration $(buildConfig) `
              --output $outputPath `
              --no-build `
              --verbosity normal
          
          if ($LASTEXITCODE -ne 0) {
              throw "dotnet publish falló con código de salida: $LASTEXITCODE"
          }
          
          Write-Host "✓ Publicación completada exitosamente"
          
          # Verificar archivos críticos
          $hostJsonPath = Join-Path $outputPath "host.json"
          if (-not (Test-Path $hostJsonPath)) {
              throw "host.json no encontrado en la salida"
          }
          
          Write-Host "✓ host.json encontrado"
          
          # Listar contenido para debugging
          Write-Host "=== Contenido del directorio de salida ==="
          Get-ChildItem -Path $outputPath -Recurse | ForEach-Object {
              Write-Host "  $($_.FullName.Replace($outputPath, ''))"
          }
          
          # Crear ZIP
          Write-Host "Creando archivo ZIP..."
          $zipPath = "$(Build.ArtifactStagingDirectory)/function-app.zip"
          
          Compress-Archive -Path "$outputPath/*" -DestinationPath $zipPath -Force
          
          if (-not (Test-Path $zipPath)) {
              throw "No se pudo crear el archivo ZIP"
          }
          
          $sizeMB = [Math]::Round((Get-Item $zipPath).Length / 1MB, 2)
          Write-Host "✓ ZIP creado exitosamente: $sizeMB MB"
          
          # Verificar contenido del ZIP
          Write-Host "=== Contenido del ZIP ==="
          Add-Type -AssemblyName System.IO.Compression.FileSystem
          $zip = [System.IO.Compression.ZipFile]::OpenRead($zipPath)
          $zip.Entries | ForEach-Object {
              Write-Host "  - $($_.FullName)"
          }
          $zip.Dispose()
          
          Write-Host "=== Proceso completado exitosamente ==="
          exit 0
          
      } catch {
          Write-Host "##vso[task.logissue type=error]Error: $($_.Exception.Message)"
          Write-Host "##vso[task.logissue type=error]StackTrace: $($_.ScriptStackTrace)"
          exit 1
      }


- task: PowerShell@2
  displayName: 'Debug - List all files'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "=== Archivos en Build.SourcesDirectory ==="
      Get-ChildItem "$(Build.SourcesDirectory)" -Recurse | Select-Object FullName, Length
      
      Write-Host "=== Archivos en ArtifactStagingDirectory ==="
      Get-ChildItem "$(Build.ArtifactStagingDirectory)" -Recurse | Select-Object FullName, Length


# Reemplazar solo el paso de deploy con esto:
- task: AzureFunctionApp@2
  displayName: 'Deploy using built-in task'
  inputs:
    connectedServiceNameARM: '$(azureSubscription)'
    appType: 'functionApp'
    appName: '$(functionAppName)'
    package: '$(Build.ArtifactStagingDirectory)/function-output'
    deploymentMethod: 'zipDeploy'
    # Configuración específica para .NET 8 isolated
    appSettings: |
      -FUNCTIONS_EXTENSION_VERSION ~4
      -FUNCTIONS_WORKER_RUNTIME dotnet-isolated
      -WEBSITE_RUN_FROM_PACKAGE 0